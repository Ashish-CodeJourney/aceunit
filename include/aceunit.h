#ifndef ACEUNIT_H
#define ACEUNIT_H

#include <stddef.h>
#include <stdbool.h>

/** Fixture information.
 * This will usually be auto-generated by `gentest.sh`.
 */
typedef struct {
    /** Pointer to the `beforeAll()` method of the fixture, if present, otherwise `NULL`.
     * `beforeAll()` will be called once per fixture, before anything else.
     */
    void (*const beforeAll)();

    /** Pointer to the `afterAll()` method of the fixture, if present, otherwise `NULL`.
     * `afterAll()` will be called once per fixture, after anything else.
     */
    void (*const afterAll)();

    /** Pointer to the `beforeEach()` method of the fixture, if present, otherwise `NULL`.
     * `beforeEach()` will be called once per testcase, before the testcase.
     */
    void (*const beforeEach)();

    /** Pointer to the `afterEach()` method of the fixture, if present, otherwise `NULL`.
     * `afterEach()` will be called once per testcase, after the testcase.
     */
    void (*const afterEach)();

    /** Pointer to the array of test cases. */
    void (*const *testcases)();
} AceUnit_Fixture_t;

/** Result of a test run. */
typedef struct {
    /** The number of test cases that were executed. */
    int testCaseCount;

    /** The number of test cases that completed successfully. */
    int successCount;

    /** The number of failures in testcases and fixture methods. */
    int failureCount;
} AceUnit_Result_t;

/** The global fixtures. */
extern const AceUnit_Fixture_t *fixtures[];

/** Run AceUnit for the given list of fixtures.
 *
 * @note Don't forget to initialize \p results.
 * The function does not initialize \p results intentionally.
 * This way, multiple runs can be collected together in the same results.
 *
 * @param fixtures Pointer to the fixtures to run, must not be `NULL`, must be terminated with `NULL`.
 * @param result Where to store the results, must not be `NULL`.
 */
extern void AceUnit_run(const AceUnit_Fixture_t *fixtures[], AceUnit_Result_t *result);

/** Run a function, catching some types of errors.
 * Implementations must guarantee that they only ever return `true` upon successful completion of the function.
 * Implementations are allowed to not return at all in case of errors.
 * What types of errors are caught and converted to `false` is implementation defined.
 * @param code Function to run.
 * @return Whether the function was executed successfully.
 * @retval true when the function was executed successfully.
 * @retval false otherwise
 */
extern bool runCatching(void(*code)());

/** Fail and abort a test case.
 * Implementations may use different mechanisms for how to actually fail the test case.
 * Popular implementations could be:
 * - `longjmp()` which would work anywhere including most freestanding environments.
 * - `abort()` which would work on all hosted environments.
 * - `exit()` which would work with `AceUnit_Fork`.
 */
extern void AceUnit_fail();

#ifndef assert
#include <stdio.h>
/** Assert a condition.
 * If the condition is \c false, this will call #AceUnit_fail().
 * @param cond  Condition to assert.
 */
#define assert(cond) \
    do { \
        if (!(cond)) { \
            fprintf(stderr, "%s:%d: %s: Assertion `%s' failed.\n", __FILE__, __LINE__, __func__, #cond); \
            AceUnit_fail(); \
        } \
    } while (false)
#endif

#endif
